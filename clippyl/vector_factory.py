import pysam
from clippyl.ome_dict_io import SiteTuple, OmeDict
from clippyl.pysam_cbs import (fetch_hitsclip_dict, 
                               fetch_iclip_dict, 
                               fetch_parclip_dict)


class build_hitsclip_vectors():
    '''
    Generate basewise counts for 1D, cleavage and raw coverage from the 
    set of alignments from the reference interval defined in the site_tup.
    This function parses the list of dictionaries generated by the pysam
    indexed bam file interface function at ??.
    Note: if the cleav_db_fp is set to None then it is assumed that all
    the reads in the sam file are adapter-clipped
    '''
    
    def __init__(self):
        
        self.stat_dict = {}
        self.stat_dict['n_of_reads'] = 0
        self.stat_dict['n_of_strand_matched_reads'] = 0
        self.stat_dict['n_of_unique_aligns'] = 0 #gleaned from sam XT opt field
        self.stat_dict['n_of_adapter_clipped_reads'] = 0
        
        self.stat_dict['n_of_nt_covered'] = 0
        self.stat_dict['n_of_nt_termini'] = 0
        self.stat_dict['n_of_oneD_operations'] = 0
        
        return
    
    def __call__(self, ome_coords,
                       pysam_bam_file_conn,
                       cleaved_readid_db_conn = None,
                       all_adapter_clipped = False,
                       uniq_only = True):
        
        reference, start, end, strand = ome_coords
        
        # fetch the bam-encoded alignment data for the region
        # delineated by the ome_coords.
        # note that it will also return reads that are only
        # partially overlapping with the region
        c = fetch_hitsclip_dict()
        pysam_bam_file_conn.fetch( reference,
                                   start,
                                   end,
                                   callback = c )
        fetched_alignments = c.l
        self.stat_dict['n_of_reads'] = len(fetched_alignments)
        
        # instantiate OmeDict, which will aggregate and then output the
        # relevant basewise data as it is gleaned from the alignment data
        raw_cover_cd = OmeDict()
        cleavage_cd = OmeDict()
        oned_rate_cd = OmeDict()
        
        for d in fetched_alignments:
            
            if strand == d['strand']:
                pass
            else:
                continue
            self.stat_dict['n_of_strand_matched_reads'] += 1
            
            #identify uniquely aligned reads by accessing the sam optdict
            if d['OPT_XT'] == 'U':
                self.stat_dict['n_of_unique_aligns'] += 1
            elif uniq_only:
                continue
            else:
                pass
            
            ####
            #store basewise raw coverage data in OmeDict
            raw_cover_st = SiteTuple(reference,
                                     start = d['POS'],
                                     end = d['AEND'],
                                     strand = d['strand'],
                                     data = 1)
            raw_cover_cd.add_site_tuple( raw_cover_st )
            
            ####
            #store basewise cleavage data in OmeDict (if present)
            self.adapter_clipped_bool = all_adapter_clipped
            if cleaved_readid_db_conn:
                if cleaved_readid_db_conn.readid_lookup(d['QNAME']):
                    self.adapter_clipped_bool = True
                    self.stat_dict['n_of_adapter_clipped_reads'] += 1
                else:
                    pass
            else:
                pass
            
            if self.adapter_clipped_bool or all_adapter_clipped:
                #add left cleavage site
                left_terminus_st = SiteTuple(reference,
                                           start = d['POS'],
                                           end = d['POS'] + 1,
                                           strand = d['strand'],
                                           data = 1)
                cleavage_cd.add_site_tuple( left_terminus_st )
                
                #add right cleavage site
                right_terminus_st = SiteTuple(reference,
                                            start = d['AEND'] - 1,
                                            end = d['AEND'],
                                            strand = d['strand'],
                                            data = 1)
                cleavage_cd.add_site_tuple( right_terminus_st )
            
            ####
            # store 1D (aka single nucleotide deletion) data in OmeDict
            # note: pysam uses an integer key to refer to CIGAR operations
            # http://pysam.readthedocs.org/en/latest/api.html#pysam.AlignedRead.cigar
            # deletion operations are coded as a 2
            if (2, 1) in d['CIGAR']:
                # the postional index of the alignment
                # operation (on the reference) will be
                # stored as i
                i = -1
                for operation, length in d['CIGAR']:
                    if operation != 1:
                        i += length
                        if operation == 2 and length == 1:
                            oneD_st = SiteTuple(reference,
                                                start = d['AEND'] - 1,
                                                end = d['AEND'],
                                                strand = d['strand'],
                                                data = 1)
                            oned_rate_cd.add_site_tuple(oneD_st)
                        else:
                            pass
        
        # output the data vectors. note that the bottom strand entries are
        # reversed by default, thereby orienting the top and bottom strands
        # to have the same 5'->3' polarity.
        vector_tuple = ( raw_cover_cd.get_data(ome_coords),
                         cleavage_cd.get_data(ome_coords),
                         oned_rate_cd.get_data(ome_coords) )
        
        self.stat_dict['n_of_nt_covered'] = sum(vector_tuple[0])
        self.stat_dict['n_of_nt_termini'] = sum(vector_tuple[1])
        self.stat_dict['n_of_oneD_operations'] = sum(vector_tuple[2])
        
        return vector_tuple

##TESTING
##http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&position=chr11%3A118964585-118966177&hgsid=369409831_ZPHI1ErsOPVE9y4sB1fWqubbTvzV
##note these are hg19 coords
#ome_coords = ('chr11', 118964584, 118966177, '-')
#bam_fp = '/home/lbthrice/Desktop/data_sample/Brooks_SLBP/s_1xS01_sequence.PP.bwa-hg19.bam'
#cleaved_readid_db_fp = 's_1xS01_sequence.PP.readids'
#with pysam.Samfile( bam_fp, "rb" ) as bam_conn, \
#     ReadidSQLite( cleaved_readid_db_fp ) as readid_conn:
#    
#    ome_coords = ref, start, end, strand
#    
#    f = build_hitsclip_vectors()
#    t = f( ome_coords,
#           bam_conn, 
#           cleaved_readid_db_conn = readid_conn )
#    
#    raw_cover_l, cleavage_l, oned_rate_l = t
#    
#    f.stat_dict
##Out[2]: 
##{'n_of_adapter_clipped_reads': 431,
## 'n_of_nt_covered': 24749,
## 'n_of_nt_termini': 862,
## 'n_of_oneD_operations': 45,
## 'n_of_reads': 1048,
## 'n_of_strand_matched_reads': 1047,
## 'n_of_unique_aligns': 895}
